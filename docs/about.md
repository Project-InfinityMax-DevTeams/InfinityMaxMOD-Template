# 1. MODの仕組みと作り方

この MOD フレームワークは、
**「Minecraft MOD を “宣言的に” 書く」**ことを目的として設計されています。

Forge / Fabric の違い、初期化順序、Registry の罠、Client / Server 分離など、
従来 MOD 開発で毎回悩まされてきた要素を DSL とライフサイクルで吸収し、

「何を追加したいか」だけを書けば、
「いつ・どこで・どう登録されるか」はフレームワークが処理する

という構造を取っています。

## 1.1 全体像（まずこれだけ覚えてください）

この MOD は、大きく3層構造になっています。
```
[ あなたのMODコード ]
        ↓
[ 共通API / DSL層 ]
        ↓
[ Loader / Platform層 (Forge / Fabric) ]
```

・あなたのMODコード
・ブロック・アイテム・イベントなどを DSL で宣言する場所
・基本的に「触るのはここだけ」
・共通API / DSL層
・登録処理・初期化順序・Client/Server 分離を管理
・フレームワークの心臓部
・Loader / Platform層
・Forge / Fabric ごとの差分を吸収
・直接触る必要はほぼない

この分離によって、
・Forge / Fabric の違いを意識しない
・初期化順序で事故らない
・Client クラスを Server で誤ロードしない

という状態を作っています。

## 1.2 MOD が起動するまでの流れ（実行の流れ）

「Minecraft 起動 → MOD が動く」までの流れを、時系列で説明します。

### ① Minecraft が MOD を検出する
・Fabric: fabric.mod.json
・Forge: META-INF/mods.toml

ここで、
・MOD ID
・エントリポイント
・対応バージョン

などが読み込まれます。

※ この時点では あなたの DSL コードはまだ実行されていません。

### ② Loader Entrypoint が呼ばれる

Forge / Fabric それぞれに対応した Entrypoint クラスが呼ばれます。

このクラスの役割は ただ一つ：

「共通ライフサイクルを正しいタイミングで起動すること」

ここでは、
・Registry 初期化
・Event 登録
・Client 専用処理の分岐
などを 直接書きません。

### ③ ライフサイクルが起動する

このフレームワークでは、MOD の初期化を
明示的なライフサイクル段階に分けています。

例（概念）：
・COMMON_INIT
・REGISTRY
・CLIENT_INIT
・SERVER_INIT

あなたが DSL で書いた処理は、

「このライフサイクル段階で実行される」

という形で 登録だけされており、
実行そのものは Loader 側が行います。

### ④ DSL による宣言が実体化する

例えば、
・ブロック DSL → Registry に登録
・イベント DSL → EventBus に接続
・Client DSL → Client 環境でのみ実行

というように、
宣言された内容が、適切なタイミングで実体化します。

重要なのは：

DSL を書いた時点では「登録されない」
ライフサイクルが来て初めて「登録される」

という点です。

## 1.3 推奨ディレクトリ構成（これで迷わない）

このフレームワークでは、
役割ごとにディレクトリを分けることを強く推奨します。
```
src/main/java/
└ com/yourname/yourmod/
   ├ ModMain.java              ← MODの入口（最小）
   │
   ├ content/                 ← 触る場所①：オブジェ定義
   │  ├ blocks/
   │  ├ items/
   │  ├ entities/
   │  └ blockentities/
   │
   ├ client/                  ← 触る場所②：Client専用DSL
   │
   ├ logic/                   ← 触る場所③：カスタムロジック
   │
   └ api/                     ← 触らない（DSL本体）
```

各ディレクトリの意味
ModMain.java
・DSL を呼び出すだけ
・ロジックを書かない
content/
・ブロック・アイテム・エンティティなどの宣言
・「何を追加するか」を書く場所
client/
・レンダリング、GUI、キー設定など
・Client 専用 DSL のみを書く
logic/
・独自処理、計算、AI、状態管理など
・Minecraft API 依存でも OK
api/
・フレームワーク内部
・触らない・改造しない

## 1.4 触ってはいけない場所（重要）

以下は 基本的に編集禁止です。
・loader/
・api/（DSL 本体・Lifecycle・Platform）
・Forge / Fabric の Platform 実装

理由は単純で、

ここは「MODを書く人」ではなく
「フレームワークを書く人」の領域

だからです。

ここを触り始めると、
・Loader 不整合
・Client/Server 混線
・初期化順バグ

が発生します。

⸻

1.5 「MODを書く」とは何をすることか

このフレームワークにおいて、
MOD を書くとは 次の3つだけを行うことです。
	1.	DSL でオブジェを宣言する
	・ブロック、アイテム、イベントなど
	2.	必要ならロジックを書く
	・独自挙動、状態管理、計算処理
	3.	Client 専用処理を分離して書く
	・描画・UI・入力

「いつ登録するか」「どの環境で動くか」は
一切考えなくていい。

## 1.6 なぜこの構造なのか（思想）

Minecraft MOD 開発が難しい理由は、
・初期化順が暗黙的
・Loader 差分が侵食してくる
・Client/Server 分離が事故る

という 構造的な問題にあります。

このフレームワークはそれを、
・明示的ライフサイクル
・宣言型 DSL
・Platform 完全分離

で 物理的に事故れない構造にしています。

ここまで理解できれば、
・どこに何を書くか
・なぜその場所なのか
・何を書かなくていいのか

が一気に解決します。